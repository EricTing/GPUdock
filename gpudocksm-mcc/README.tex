% Created 2013-12-30 Mon 20:49
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\author{Yun Ding}
\date{\today}
\title{README}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2)}}
\begin{document}

\maketitle
\tableofcontents

\section{Preface}
\label{sec-1}
GPU ligand docking project.
\begin{itemize}
\item The implementation of ligand docking on GPU architecture
\item Replica-exchange Monte Carlo method ussed as the searching method
\end{itemize}

\section{Developers' log}
\label{sec-2}
\subsection{{\bfseries\sffamily DONE} Data structure from array of structure (AoS) to structure of array (SoA)}
\label{sec-2-1}

\subsection{{\bfseries\sffamily DONE} Energy calculation and Metropolis Monte Carlo}
\label{sec-2-2}
\subsubsection{{\bfseries\sffamily DONE} perturbation of ligand}
\label{sec-2-2-1}
\begin{enumerate}
\item {\bfseries\sffamily DONE} c++ code
\label{sec-2-2-1-1}
\begin{itemize}
\item $\boxtimes$ in loading, the coord of original ligand should be guaranteed to be in its center reference
\item $\boxtimes$ after loading, the coord of original ligand should be guaranteed to be in its center reference
stored in
\begin{verbatim}
LigCoord *coord_orig = &mylig->coord_orig;
\end{verbatim}
\item $\boxtimes$ InitLigCoord added, to initialize the original coord of the ligand
\begin{verbatim}
void InitLigCoord (Ligand *, const ComplexSize);
\end{verbatim}
\item $\boxminus$ in perturbation
\begin{itemize}
\item c++ code
\end{itemize}
\begin{verbatim}
double boltzmann     = 1.0;
double step_t        = 1.0;
double step_r        = 5.0;
\end{verbatim}
\begin{verbatim}
for ( int i = 0; i < 3; i++ )
{
mc_conf3[i] = mc_conf1[i];

mc_conf1[i] += mc_t * unirand( -1, 1 );
}

for ( int i = 3; i < 6; i++ )
{
mc_conf3[i] = mc_conf1[i];

mc_conf1[i] += ( ( mc_r * unirand( -1, 1 ) ) * PI ) / 180.0;
}
\end{verbatim}
\begin{verbatim}
if ( unirand( 0, 1 ) > exp( ( -1.0 * ( mc_energy - energy_old ) ) / ( mc_b * mc_temp ) ) )
\end{verbatim}
\end{itemize}

\item {\bfseries\sffamily DONE} cuda code
\label{sec-2-2-1-2}
\begin{itemize}
\item cuda code
\item $\boxtimes$ same scale as in the c++ code
\begin{verbatim}
const float t = 1.0f;
const float r = 5.0f;
\end{verbatim}
\item $\boxtimes$ same translation vector applied
\begin{verbatim}
// pocket center coord should be added here rathre than the ligand center
coord_new->x[l] = rot[0][0] * x + rot[0][1] * y + rot[0][2] * z + r[0] + cx;
coord_new->y[l] = rot[1][0] * x + rot[1][1] * y + rot[1][2] * z + r[1] + cy;
coord_new->z[l] = rot[2][0] * x + rot[2][1] * y + rot[2][2] * z + r[2] + cz;
\end{verbatim}

\item rotation matrix applied
\item calculating the ligand center
\item $\boxtimes$ set extremely high temperature to force the acceptance of each perturbation
\begin{itemize}
\item $\boxtimes$ check the translation part
\begin{itemize}
\item the new center is just the old center vecotor plus the translation vector
\item if only tanslation applied
\end{itemize}
\item $\boxtimes$ check the rotation part
\end{itemize}
\item $\boxtimes$ check by implementing a regular pattern of perturbation
\#+BEGIN$_{\text{SRC}}$
\end{itemize}
\#if COMPILE
      // perturbation depends on the step number
      if (step\%2 == 0)\{
        if (bidx < 6) \{
          r[bidx] = 1.0f;
        \}
        if (bidx > 2 \&\& bidx < 6) \{    
          r[bidx] = -1.0f;
        \}
        if (bidx < 6) \{
          r[bidx] += mylig->movematrix$_{\text{old[bidx]}}$;
          mylig->movematrix$_{\text{new[bidx]}}$ = r[bidx];
        \}
      \}
      else
        \{
        if (bidx < 6) \{
          r[bidx] = -1.0f;
        \}
        if (bidx > 2 \&\& bidx < 6) \{    
          r[bidx] = 1.0f;
        \}
        if (bidx < 6) \{
          r[bidx] += mylig->movematrix$_{\text{old[bidx]}}$;
          mylig->movematrix$_{\text{new[bidx]}}$ = r[bidx];
        \}
      \}
\#endif
\#+END$_{\text{SRC}}$
\begin{itemize}
\item $\boxtimes$ the edst is not correct
\begin{itemize}
\item $\boxtimes$ correct the way to calculate the new center
\#+BEGIN$_{\text{SRC}}$
\end{itemize}
\end{itemize}
for (int i = 0; i < 3; ++i) \{ 
  \emph{/ coord$_{\text{new}}$->center[i] += r[i]; /} incorrect codes
  coord$_{\text{new}}$->center[i] = coord$_{\text{orig}}$->center[i] + mylig->movematrix$_{\text{new[i]}}$; // correct 
\}
\#+END$_{\text{SRC}}$
\end{enumerate}
\subsubsection{{\bfseries\sffamily DONE} correct the pmf energy calculation}
\label{sec-2-2-2}
\begin{itemize}
\item energy of pmf slightly different compared with c++ codes result until r190 in svn log
\item the result is different in the third digit after the desimal
\end{itemize}
\begin{enumerate}
\item {\bfseries\sffamily DONE} check the pmf calculation
\label{sec-2-2-2-1}
\begin{itemize}
\item correct c++ code
\#+BEGIN$_{\text{SRC}}$
\end{itemize}
\_epmf += \_complex$_{\text{pmf[}}$(*ip1).getPointType()][(*il1).getAtomType()]\footnote{DEFINITION NOT FOUND.}
\begin{itemize}
\item 1.0 / ( 1.0 + exp( ( -0.5 * dst + 6.0 ) * ( dst - \_complex$_{\text{pmf[}}$(*ip1).getPointType()][(*il1).getAtomType()]\footnote{DEFINITION NOT FOUND.} ) ) );
\#+END$_{\text{SRC}}$
\begin{itemize}
\item cuda code
\begin{verbatim}
const float dst_minus_pmf0 = dst - enepara_dc->pmf0[lig_t][prt_t];

epmf[bidx] +=
  enepara_dc->pmf1[lig_t][prt_t] /
  (1.0f + expf ((-0.5f * dst + 6.0f) * dst_minus_pmf0));
\end{verbatim}
\end{itemize}
\end{itemize}

\item {\bfseries\sffamily DONE} correct the pmf calculation
\label{sec-2-2-2-2}
pmf calculated to be correct after using the movematrix to record the trail of the system
\end{enumerate}


\subsubsection{{\bfseries\sffamily DONE} figure out the coordinate ref system of the ligand, ligand center and protein center}
\label{sec-2-2-3}
\begin{enumerate}
\item {\bfseries\sffamily DONE} how upgraded in the serial C++ code
\label{sec-2-2-3-1}
\begin{enumerate}
\item both ligand and prt center initialized at (0, 0, 0) coordinate
\label{sec-2-2-3-1-1}
\begin{verbatim}
for ( int ai = 0; ai < 3; ai++ )
{
  _pocket_center[ai] = 0.0;
  _ligand_center[ai] = 0.0;
}
\end{verbatim}

\item both updated simultaneously, equal to the center of the coords loaded from the .sdf file
\label{sec-2-2-3-1-2}
\begin{verbatim}
for ( int i5 = 0; i5 < 3; i5++ )
 {
  _ligand_center[i5] /= (double) _lna;
  _pocket_center[i5] /= (double) _lna;
 }
\end{verbatim}

\item ligand moved to the center-of-mass frame
\label{sec-2-2-3-1-3}
\begin{verbatim}
for ( int i1 = 0; i1 < _lna; i1++ )
  for ( int i5 = 0; i5 < 3; i5++ )
   tmp8[i1][i5] -= _ligand_center[i5];

 vector<CoordsLigand>::iterator i4;

 for ( i4 = _ligand_xyz.begin(); i4 < _ligand_xyz.end(); i4++ )
  (*i4).setCoords( tmp8[(*i4).getAtomNumber()][0], tmp8[(*i4).getAtomNumber()][1],tmp8[(*i4).getAtomNumber()][2], _lens_total );
\end{verbatim}

\item ligand center initialized at (0,0,0) in calculating energy
\label{sec-2-2-3-1-4}
\begin{verbatim}
for ( int il5 = 0; il5 < 3; il5++ )
 _ligand_center[il5] = 0.0;
\end{verbatim}

\item rotation matrix directly applied to the ligand coord with respective to the lab
\label{sec-2-2-3-1-5}
\begin{verbatim}
for ( int il4 = 0; il4 < 3; il4++)
{
 for ( int il2 = 0; il2 < 3; il2++)
 {
  t_xyz[il2] = 0.0;

  for ( int il3 = 0; il3 < 3; il3++)
   t_xyz[il2] += b_xyz[il3] * r_mat[il4][il3][il2];
 }

 for ( int il2 = 0; il2 < 3; il2++)
  b_xyz[il2] = t_xyz[il2];
}
\end{verbatim}
\end{enumerate}
\end{enumerate}
\subsubsection{{\bfseries\sffamily DONE} pocket$_{\text{center}}$ accompany the protein structure}
\label{sec-2-2-4}
\begin{itemize}
\item $\boxtimes$ pocket$_{\text{center}}$ the same for all ligand conformations loaded from the same .sdf file
\item $\boxtimes$ pocket$_{\text{center}}$ is a proporty of each replica and be used in every energy calculation
\end{itemize}

\begin{enumerate}
\item {\bfseries\sffamily TODO} how invloved in the energy calculation and Monte Carlo
\label{sec-2-2-4-1}
\end{enumerate}
\subsection{{\bfseries\sffamily DONE} move the load weight function to load.h and load.C}
\label{sec-2-3}
\subsection{{\bfseries\sffamily DONE} calculation of acceptance ratio added}
\label{sec-2-4}

\section{testing}
\label{sec-3}


\subsection{{\bfseries\sffamily TODO} Replica-exchange Monte Carlo mode}
\label{sec-3-1}
mode describes the exchanging pattern of the ligand and temperature across all the replicas
\subsubsection{{\bfseries\sffamily TODO} temperature exchange mode}
\label{sec-3-1-1}
\begin{enumerate}
\item {\bfseries\sffamily TODO} testing the parallel tempering
\label{sec-3-1-1-1}
\end{enumerate}
\subsubsection{{\bfseries\sffamily TODO} which mode supposts complete information exchange}
\label{sec-3-1-2}
\begin{itemize}
\item mode0 and mode1 combined together provides a mechanism that can do a complete information
\end{itemize}

\subsection{{\bfseries\sffamily TODO} search the lowest energy in the track}
\label{sec-3-2}
to find the lowest energy and the corresponding configuration in each replica

\subsubsection{{\bfseries\sffamily TODO} more functions in analysis.C}
\label{sec-3-2-1}

\subsubsection{{\bfseries\sffamily TODO} in production version, every step has to be recorded, which generate redunancy}
\label{sec-3-2-2}
\begin{enumerate}
\item because memory allocated for recording would be left with some unused space 
if only the accepted configuration information is recorded
\item about 9.0\% performace would be lost due to recording redundancy information
\end{enumerate}
\begin{enumerate}
\item {\bfseries\sffamily TODO} record
\label{sec-3-2-2-1}
\begin{itemize}
\item $\square$ total energy
\item $\square$ movematrix
\item $\square$ ligand conformation and protein conformation
\end{itemize}

\item {\bfseries\sffamily TODO} estimate hard disk requirement
\label{sec-3-2-2-2}
\begin{itemize}
\item $\square$ set total steps and total temperature from cmd
\end{itemize}
\end{enumerate}

\subsection{{\bfseries\sffamily TODO} why care about the \# mcs ??}
\label{sec-3-3}
\begin{verbatim}
complexsize.n_pos = inputfiles->lhm_file.n_pos;	// number of MCS positions
\end{verbatim}

\subsection{{\bfseries\sffamily DONE} simplist monte carlo implementation}
\label{sec-3-4}

\subsubsection{to diagnose one replica}
\label{sec-3-4-1}
\begin{verbatim}
const int myreplica = 0; // the # of replica chosen to print
\end{verbatim}
\subsubsection{{\bfseries\sffamily DONE} testing single temperature Monte Carlo}
\label{sec-3-4-2}
\begin{itemize}
\item $\boxtimes$ subscript in bounds in accept$_{\text{d}}$.cu
solved
\item $\boxtimes$ in perturbing the ligand, MyRand$_{\text{d}}$() is always positive
solved
\item initialize the ligand away from the native pose, run single temperature Monte Carlo
\begin{enumerate}
\item track the dst energy
dst energy decreases through the process, see
gpudocksm-rem-1.2/src/edst$_{\text{single}}$$_{\text{temp}}$$_{\text{MC}}$$_{\text{away}}$$_{\text{center}}$.pdf
\item track the vdw energy
vdw energy fluctuats, see
gpudocksm-rem-1.2/src/evdw$_{\text{single}}$$_{\text{temp}}$$_{\text{MC}}$$_{\text{away}}$$_{\text{center}}$.pdf
\end{enumerate}
\item initialize the ligand at the native pose
\begin{enumerate}
\item track the dst energy
dst energy fluctuats at a low level, indicating the ligand moveing aournd the native pose, see
gpudocksm-rem-1.2/src/edst$_{\text{single}}$$_{\text{temp}}$$_{\text{MC}}$$_{\text{at}}$$_{\text{center}}$.pdf
\end{enumerate}
\end{itemize}
\subsection{{\bfseries\sffamily DONE} argument parsing}
\label{sec-3-5}
\begin{verbatim}
void
ParseArguments (int argc, char **argv, McPara * mcpara, InputFiles * inputfiles);
\end{verbatim}
\subsection{{\bfseries\sffamily DONE} modify energy calculation if needed}
\label{sec-3-6}
\begin{itemize}
\item weight abtained from using /home/jaydy/work/dat/output/output/FF$_{\text{opt}}$/0.8.ff
\item applying the linear transformation normalized$_{\text{df}}$ = a*df + b
\begin{verbatim}
inputfiles->norpara_file.path_a = "../dat/linear_a";
inputfiles->norpara_file.path_b = "../dat/linear_b";
\end{verbatim}
\begin{center}
\begin{tabular}{lr}
a: & \\
\hline
\_evdw & 0.746595\\
\_eele & 18.289225\\
\_epmf & 0.282088\\
\_ehpc & 0.427256\\
\_ehdb & 2.147791\\
\_edst & 0.497450\\
\_epsp & 0.572314\\
\_ekde & 233.329020\\
\_elhm & 0.726683\\
\hline
b: & \\
\hline
\_evdw & 1.036550\\
\_eele & -0.028357\\
\_epmf & 0.256679\\
\_ehpc & -1.023866\\
\_ehdb & 1.000000\\
\_edst & -1.000000\\
\_epsp & 0.001993\\
\_ekde & -1.000000\\
\_elhm & -0.294676\\
\end{tabular}
\end{center}
\item $\boxtimes$ 18 more float number from normalization parameter in the device constant

\item $\boxtimes$ abort to optimize calculat combination due to its low cost
\end{itemize}
\subsection{{\bfseries\sffamily DONE} introduce the toggle of random walk}
\label{sec-3-7}
\begin{verbatim}
mcpara->if_random = 1; // random walk by default
\end{verbatim}
\subsection{{\bfseries\sffamily DONE} load the weight from file}
\label{sec-3-8}
\begin{itemize}
\item old
\end{itemize}
\begin{verbatim}
mylig->etotal[mylig->track] =
  enepara_dc->w[0] * evdw[0] +
  enepara_dc->w[1] * eele[0] +
  enepara_dc->w[2] * epmf[0] +
  enepara_dc->w[3] * epsp[0] +
  enepara_dc->w[4] * ehdb[0] +
  enepara_dc->w[5] * ehpc[0] +
  enepara_dc->w[6] * ekde[0] +
  enepara_dc->w[7] * elhm[0] +
  enepara_dc->w[8] * edst;
\end{verbatim}
\begin{itemize}
\item new
\end{itemize}
\begin{verbatim}
mylig->etotal[mylig->track] =
  enepara_dc->w[0] * evdw[0] +
  enepara_dc->w[1] * eele[0] +
  enepara_dc->w[2] * epmf[0] +
  enepara_dc->w[3] * ehpc[0] +
  enepara_dc->w[4] * ehdb[0] +
  enepara_dc->w[5] * edst +
  enepara_dc->w[6] * epsp[0] +
  enepara_dc->w[7] * ekde[0] +
  enepara_dc->w[8] * elhm[0];
\end{verbatim}

\begin{verbatim}
std::string ifn = path;

list < string > data;
list < string >::iterator data_i;

string line1;				// tmp string for each line
ifstream data_file(ifn.c_str());	// open the data_file as the buffer

if (!data_file.is_open()) {
	cout << "cannot open " << ifn << endl;
	exit(EXIT_FAILURE);
}

while (getline(data_file, line1))
	data.push_back(line1);	// push each line to the list

data_file.close();			// close

int total_weight_item = data.size();
int weight_iter = 0;

for (weight_iter = 0, data_i = data.begin(); weight_iter < total_weight_item && data_i != data.end(); weight_iter++, data_i++) {	// interate the list
	string s = (*data_i).substr(0, 30);
	istringstream os(s);
	double tmp = 0.0;
	os >> tmp;				// this tmp is what you need. do whatever you want with it
	enepara->w[weight_iter] = tmp;
}
\end{verbatim}
\subsection{{\bfseries\sffamily DONE} What does output$_{\text{20131205}}$$_{\text{105456}}$/a$_{\text{XXXX}}$.h5's xxxx stand for ???}
\label{sec-3-9}
to leave 4 digits

\subsection{{\bfseries\sffamily DONE} check the temperature settings}
\label{sec-3-10}
% Emacs 24.3.1 (Org mode 8.2)
\end{document}
